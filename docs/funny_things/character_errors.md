# 锟斤拷与烫烫烫

## 概述
想必大家都知道`锟斤拷烫烫烫`这个梗吧

这其中包含了两个部分，一个是`锟斤拷`，一个是`烫烫烫`

这篇文章就来解释这两个梗

## 锟斤拷

### 来源
锟斤拷的问题其实非常简单，就是文本编码问题

在`Unicode`这套编码规范里，规定`�`为`EF BF BD`

即无效的码点值在编码的时候会默认用这个码点值进行替换，即`Unicode`中的超级「备胎」(`REPLACEMENT CHARACTER`)。

然而，复制粘贴后，将其转换为`GBK`编码时，内容就变了，就变成了`锟斤拷`，

下面这一段阐述了锟斤拷的来源

```
UNICODE	�		|�
BINARY	EF BF BD EF BF BD
GBK		锟   |斤   |拷
```

### 重现

1. 打开记事本
2. 输入`��`
3. 另存为该文件
4. 在右下角选择编码为`ANSI`
5. 保存并关闭
6. 再次打开该文件

注：`ANSI`编码并非正式编码，意味着根据操作系统来选择编码，只有在中文系统上，才是`GBK`。例如在繁体中文系统上，则是`BIG5`编码。

## 烫烫烫

### 来源
这是`MSVC`的调试机制，每次定义一个变量、数组、指针，如果未初始化，在`gcc`编译器上会输入随机垃圾数据，而在`MSVC`编译器上会往变量里填充`0xcc`。

根据[C语言类型简述](/coding/c_cpp_types.html)关于类型的讲述，我们就可以还原这个`烫烫烫`的问题了

### 概念
`char` 类型占用1字节(8-bit)，可以输出半个`烫`:sweat:

不对不对，应该是`Ì`(`0xcc`)

上一篇文章中讲过

> 可以表示-127～128之间的任意整数
>
> 也就是Ascii码中的任何字符

`char` 类型会自动解析为`Ascii`编码

那么 `0xcc`在`Ascii`中表示`204`

由于溢出问题，在`char`类型里会变成`-52` (原因：在`char`类型中，`128+1= -127`)

但在解析成`Ascii`的过程中，会把它转换为`unsigned char`，就是把`-52`变成了`204`，就变成了`Ì`

---
`int` 类型占用4字节(32-bit)，只需要编写以下C/C++代码(`MingW/gcc`编译)
```C
#include <stdio.h>
int main(){
    int a=0xcccc; //或者52428
    printf("%c",a);
}
```
就可以输出1个`烫`了

> 不要问我为什么要设置成这么奇怪的数字

由于`GBK`和`GB2312`的双字节特性，该`int`类型的`0xcccc`会被解析为`char[2]`，即`{0xcc,0xcc}`

```
BINARY	CC CC
GBK		烫
```
