import{_ as a,c as s,o as i,a6 as n}from"./chunks/framework.Bfj_fQo8.js";const k=JSON.parse('{"title":"锟斤拷与烫烫烫","description":"","frontmatter":{},"headers":[],"relativePath":"funny_things/character_errors.md","filePath":"funny_things/character_errors.md","lastUpdated":1755150079000}'),c={name:"funny_things/character_errors.md"};function d(o,e,p,t,l,r){return i(),s("div",null,e[0]||(e[0]=[n(`<h1 id="锟斤拷与烫烫烫" tabindex="-1">锟斤拷与烫烫烫 <a class="header-anchor" href="#锟斤拷与烫烫烫" aria-label="Permalink to &quot;锟斤拷与烫烫烫&quot;">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><p>想必大家都知道<code>锟斤拷烫烫烫</code>这个梗吧</p><p>这其中包含了两个部分，一个是<code>锟斤拷</code>，一个是<code>烫烫烫</code></p><p>这篇文章不仅解释这两个梗，还有其他跟的解释呢</p><h2 id="锟斤拷" tabindex="-1">锟斤拷 <a class="header-anchor" href="#锟斤拷" aria-label="Permalink to &quot;锟斤拷&quot;">​</a></h2><h3 id="来源" tabindex="-1">来源 <a class="header-anchor" href="#来源" aria-label="Permalink to &quot;来源&quot;">​</a></h3><p>锟斤拷的问题其实非常简单，就是文本编码问题</p><p>在<code>Unicode</code>这套编码规范里，规定<code>�</code>为<code>EF BF BD</code></p><p>即无效的码点值在编码的时候会默认用这个码点值进行替换，即<code>Unicode</code>中的超级「备胎」(<code>REPLACEMENT CHARACTER</code>)。</p><p>然而，复制粘贴后，将其转换为<code>GBK</code>编码时，内容就变了，就变成了<code>锟斤拷</code>，</p><p>下面这一段阐述了锟斤拷的来源</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>UNICODE	�		|�</span></span>
<span class="line"><span>BINARY	EF BF BD EF BF BD</span></span>
<span class="line"><span>GBK		锟   |斤   |拷</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="重现" tabindex="-1">重现 <a class="header-anchor" href="#重现" aria-label="Permalink to &quot;重现&quot;">​</a></h3><ol><li>打开记事本</li><li>输入<code>��</code></li><li>另存为该文件</li><li>在右下角选择编码为<code>ANSI</code></li><li>保存并关闭</li><li>再次打开该文件</li></ol><p>注：<code>ANSI</code>编码并非正式编码，意味着根据操作系统来选择编码，只有在中文系统上，才是<code>GBK</code>。例如在繁体中文系统上，则是<code>BIG5</code>编码。</p><h2 id="烫烫烫" tabindex="-1">烫烫烫 <a class="header-anchor" href="#烫烫烫" aria-label="Permalink to &quot;烫烫烫&quot;">​</a></h2><h3 id="来源-1" tabindex="-1">来源 <a class="header-anchor" href="#来源-1" aria-label="Permalink to &quot;来源&quot;">​</a></h3><p>这是<code>MSVC</code>的调试机制，每次定义一个变量、数组、指针，如果未初始化，在<code>gcc</code>编译器上会输入随机垃圾数据，而在<code>MSVC</code>编译器上会往变量里填充<code>0xcc</code>。</p><p>根据<a href="https://www.cnblogs.com/apkqiu/p/C-types.html" target="_blank" rel="noreferrer">上一篇文章</a>关于类型的讲述，我们就可以还原这个<code>烫烫烫</code>的问题了</p><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p><code>char</code> 类型占用1字节(8-bit)，可以输出半个<code>烫</code>😓</p><p>不对不对，应该是<code>Ì</code>(<code>0xcc</code>)</p><p>上一篇文章中讲过</p><blockquote><p>可以表示-127～128之间的任意整数</p><p>也就是Ascii码中的任何字符</p></blockquote><p><code>char</code> 类型会自动解析为<code>Ascii</code>编码</p><p>那么 <code>0xcc</code>在<code>Ascii</code>中表示<code>204</code></p><p>由于溢出问题，在<code>char</code>类型里会变成<code>-52</code> (原因：在<code>char</code>类型中，<code>128+1= -127</code>)</p><p>但在解析成<code>Ascii</code>的过程中，会把它转换为<code>unsigned char</code>，就是把<code>-52</code>变成了<code>204</code>，就变成了<code>Ì</code></p><hr><p><code>int</code> 类型占用4字节(32-bit)，只需要编写以下C/C++代码(<code>MingW/gcc</code>编译)</p><div class="language-C vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">C</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;stdio.h&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cccc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //或者52428</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">%c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,a);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>就可以输出1个<code>烫</code>了</p><blockquote><p>不要问我为什么要设置成这么奇怪的数字</p></blockquote><p>由于<code>GBK</code>和<code>GB2312</code>的双字节特性，该<code>int</code>类型的<code>0xcccc</code>会被解析为<code>char[2]</code>，即<code>{0xcc,0xcc}</code></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>BINARY	CC CC</span></span>
<span class="line"><span>GBK		烫</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>`,36)]))}const u=a(c,[["render",d]]);export{k as __pageData,u as default};
